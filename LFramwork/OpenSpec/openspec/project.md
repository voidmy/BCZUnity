# 项目背景

## 目的
这是一个使用 Unity 搭建的确定性原型项目，用来探索和验证以下内容：

- **服务器权威的确定性模拟**：在多个客户端之间同步大量角色（agents）的行为。
- **基于定点数 RVO2 的人群模拟**（角色、范围技能 AoE、边界检测、计分），并保证多机之间状态一致。
- **基于 WebSocket 的 Tick 网络同步**，包括每 Tick 的状态哈希与反同步（desync）检测。
- 在确定性核心之上进行渲染和玩法实验（例如：程序化草地、Spine 动画）。

## 技术栈
- **引擎**：Unity (C#)
- **渲染**：Universal Render Pipeline (URP)，自定义 Shader（HLSL）
- **数学 / 模拟**：
  - 定点数数学类型（`LFloat`、`LVector2` 等）
  - 定点数 RVO2 实现（`Fixed-point-number-RVO2-CS`）
- **网络**：
  - Node.js WebSocket 服务器（`ws` 风格的服务器），位于 `LFramwork/Server`
  - 自定义 C# WebSocket 客户端（含 WebGL 实现）
  - 使用 JSON 消息传输 Tick、生成、技能、状态哈希、反同步（desync）以及重置
- **工具 / 规范**：
  - 使用 OpenSpec 做规范驱动开发（`openspec/`）
  - Git 进行版本控制

## 项目约定

### 代码风格
- **语言**：C# 8 风格，遵循 Unity 常用模式。
- **命名**：
  - C# 类型：`PascalCase`
  - 方法：`PascalCase`
  - 字段：`camelCase`，私有字段通常加前缀 `_`
  - 常量：根据上下文使用 `PascalCase` 或 `ALL_CAPS`
- **格式**：
  - 4 空格缩进，禁止使用 Tab。
  - 类型 / 方法的花括号独立一行；简单代码块允许行内写法。
  - 避免过度使用 `#region`；保持文件职责单一。
- **Unity 特有约定**：
  - MonoBehaviour 中使用 `Start/Update`，但重逻辑应放到独立的管理器 / 系统中。
  - 避免在没有 Tick 控制的情况下，直接在 `Update` 中执行模拟逻辑。

### 架构模式
- **确定性模拟核心**：
  - 游戏逻辑（RVO 步进、伤害、边界检查、生成、技能）由 **服务器 Tick** 驱动，而非帧时间。
  - 模拟只使用定点数运算；核心逻辑中应避免使用浮点数，以保证确定性。
- **服务器权威网络模型**：
  - Node.js 服务器以 Tick 为单位广播权威事件（生成、技能），并附带目标 Tick 索引。
  - 客户端缓存收到的消息，并在本地 `logicTick` 达到指定 Tick 时才应用。
  - 客户端每 Tick 计算一次状态哈希并回传；服务器在发现不一致时停止 Tick 并广播 DESYNC。
- **客户端职责**：
  - 以确定性的方式消费 Tick，并在每个 Tick 调用一次 RVO 模拟器（`sim.doStep()`）。
  - 为待处理的生成 / 技能消息维护按 Tick 排序的队列。
  - 根据确定性状态驱动可见的 Transform、特效（VFX）以及 UI。
- **关注点分离**：
  - `RVODemoManager`：负责模拟及每 Tick 逻辑（生成、技能、边界、计分、哈希）。
  - `RVOClientNetwork`：负责 WebSocket 连接与消息分发。
  - `server.js`：Tick 主循环、消息路由、反同步处理、`userId` 分配。
  - 渲染 / 特效脚本（如草、Spine）不应修改模拟状态。

### 测试策略
- **反同步检测（Desync Detection）**：
  - 所有客户端每 Tick 计算一次确定性状态哈希。
  - 服务器比较各客户端哈希；若不一致则停止 Tick 并广播 DESYNC 消息。
- **手动多客户端测试**：
  - 同时运行多个 Unity 客户端连接同一个 Node.js 服务器。
  - 在消费同一 Tick 流的前提下，验证各客户端的角色数量、位置和得分是否一致。
- **重置协议（Reset Protocol）**：
  - 服务器可以广播 `reset` 命令，清空客户端状态并从 Tick 0 重新开始。
  - 用于保证一致的起始条件以及调试反同步问题。
- **临时可视化测试**：
  - 在场景中使用调试日志、Gizmos 和临时 UI 检查角色位置和状态哈希。

### Git 工作流
- **仓库结构**：
  - Unity 工程位于 `BCZUnity`，`LFramwork` 为主要工作目录。
  - 忽略 Unity 生成的目录（`Library`、`Temp`、`Logs`、`obj`）。
  - 外部定点数 RVO2 代码以源码形式提交（不使用嵌套 Git 仓库）。
- **分支策略**：
  - `main`（或 `master`）作为主集成分支。
  - 大型改动采用特性 / 实验分支。
- **提交规范**：
  - 提交应尽量小而聚焦。
  - 使用祈使句、描述性信息（如：`Add deterministic skill AoE via fixed-point distance`）。
  - 避免提交体积巨大的生成文件或仅本地使用的资源。

## 领域背景

- **核心领域**：
  - 使用 RVO2 实现实时人群模拟，支持大量角色。
  - 类似 PvP 的场景：角色从两端生成并进行碰撞 / 攻击。
- **确定性要求**：
  - 对于相同的 Tick 输入，所有客户端的游戏关键逻辑必须保持确定性。
  - Unity 的浮点 API（如 `Random`、`Time.deltaTime`、物理）不能影响模拟状态。
- **技能 / AoE**：
  - 技能以 AoE 圆形范围的形式执行，使用定点距离检测。
  - 视觉特效在客户端生成，但由确定性的 Tick 事件驱动。
- **程序化渲染实验**：
  - 使用程序化网格（如草地）和自定义 URP Shader（基于贝塞尔的弯曲）做视觉表现。
  - 这些只用于表现层，不应影响模拟确定性或网络协议。

## 重要约束

- **确定性优先**：
  - 模拟逻辑只能使用定点数类型以及确定性的容器 / 迭代顺序。
  - 逻辑内部禁止依赖实时时钟或帧率。
- **服务器权威**：
  - 服务器是 Tick 和高层事件的唯一可信来源。
  - 客户端不得在未获服务器确认的情况下引入自己的游戏事件。
- **WebGL / 平台注意事项**：
  - WebGL 使用自定义 WebSocket 实现；编写跨平台共享代码时，应避免使用 WebGL 不支持的 API。
- **性能**：
  - RVO 步进和状态哈希每 Tick 都会执行；避免每个角色在每 Tick 产生大量分配。
- **规范纪律（Spec Discipline）**：
  - 任何大的或改变行为的工作，在实现前都应先通过 OpenSpec Proposal。

## 外部依赖

- **Node.js WebSocket 服务器**（`server.js`）：
  - 提供 Tick 广播、通过命令行控制开始 / 停止，并路由生成 / 技能 / 状态哈希 / 重置等消息。
  - 为每个客户端连接分配 `userId`。
- **定点数 RVO2 库**（`Fixed-point-number-RVO2-CS`）：
  - 第三方 / 开源实现，已按本项目需求做适配。
- **OpenSpec CLI / 工具链**：
  - 用于管理 `openspec/` 下的规范与变更提案。
